import { v4 as uuidv4 } from 'uuid';
import { Payment, PaymentRequest, PaymentStatus } from '@/types';
import { ExchangeRateService } from '@/utils/ExchangeRateService';
import { TONService } from '@/blockchain/TONService';
import { Logger } from '@/utils/Logger';
import { appConfig } from '@/config';

export class PaymentService {
  private exchangeRateService: ExchangeRateService;
  private tonService: TONService;
  private logger: Logger;
  private payments: Map<string, Payment> = new Map();

  constructor() {
    this.exchangeRateService = new ExchangeRateService();
    this.tonService = new TONService();
    this.logger = new Logger('PaymentService');
  }

  public async createPayment(request: PaymentRequest): Promise<Payment> {
    try {
      this.logger.info('Creating payment', { request });

      // Validate request
      this.validatePaymentRequest(request);

      // Get exchange rate
      const exchangeRate = await this.exchangeRateService.getExchangeRate(
        request.currency,
        request.tokenType
      );

      // Calculate token amount
      const tokenAmount = this.calculateTokenAmount(request.amount, exchangeRate);

      // Generate payment ID
      const paymentId = uuidv4();

      // Create payment object
      const payment: Payment = {
        id: paymentId,
        merchantId: request.merchantId,
        amount: request.amount,
        currency: request.currency,
        tokenAmount,
        tokenType: request.tokenType,
        status: 'pending',
        createdAt: new Date(),
        expiresAt: new Date(Date.now() + appConfig.paymentTimeout),
        qrCode: '', // Will be generated by QRService
        tonAddress: '', // Will be set by TONService
        description: request.description
      };

      // Store payment
      this.payments.set(paymentId, payment);

      this.logger.info('Payment created successfully', {
        paymentId,
        amount: request.amount,
        currency: request.currency,
        tokenAmount
      });

      return payment;

    } catch (error) {
      this.logger.error('Error creating payment:', error);
      throw error;
    }
  }

  public async getPayment(paymentId: string): Promise<Payment | null> {
    return this.payments.get(paymentId) || null;
  }

  public async updatePaymentStatus(
    paymentId: string, 
    status: PaymentStatus, 
    transactionHash?: string
  ): Promise<Payment | null> {
    try {
      const payment = this.payments.get(paymentId);
      
      if (!payment) {
        this.logger.warn(`Payment not found: ${paymentId}`);
        return null;
      }

      payment.status = status;
      
      if (status === 'completed' && transactionHash) {
        payment.completedAt = new Date();
        payment.transactionHash = transactionHash;
      }

      this.payments.set(paymentId, payment);

      this.logger.info(`Payment status updated`, {
        paymentId,
        status,
        transactionHash
      });

      return payment;

    } catch (error) {
      this.logger.error('Error updating payment status:', error);
      throw error;
    }
  }

  public async getPaymentsByMerchant(merchantId: number): Promise<Payment[]> {
    return Array.from(this.payments.values())
      .filter(payment => payment.merchantId === merchantId)
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
  }

  public async getPendingPayments(): Promise<Payment[]> {
    return Array.from(this.payments.values())
      .filter(payment => payment.status === 'pending')
      .filter(payment => payment.expiresAt > new Date());
  }

  public async getExpiredPayments(): Promise<Payment[]> {
    const now = new Date();
    return Array.from(this.payments.values())
      .filter(payment => 
        payment.status === 'pending' && 
        payment.expiresAt <= now
      );
  }

  public async cancelPayment(paymentId: string): Promise<boolean> {
    try {
      const payment = this.payments.get(paymentId);
      
      if (!payment) {
        this.logger.warn(`Payment not found for cancellation: ${paymentId}`);
        return false;
      }

      if (payment.status !== 'pending') {
        this.logger.warn(`Cannot cancel payment with status: ${payment.status}`);
        return false;
      }

      payment.status = 'expired';
      this.payments.set(paymentId, payment);

      this.logger.info(`Payment cancelled`, { paymentId });

      return true;

    } catch (error) {
      this.logger.error('Error cancelling payment:', error);
      return false;
    }
  }

  public async verifyPayment(paymentId: string): Promise<boolean> {
    try {
      const payment = this.payments.get(paymentId);
      
      if (!payment) {
        this.logger.warn(`Payment not found for verification: ${paymentId}`);
        return false;
      }

      if (payment.status !== 'pending') {
        return payment.status === 'completed';
      }

      // Check if payment has expired
      if (payment.expiresAt <= new Date()) {
        await this.updatePaymentStatus(paymentId, 'expired');
        return false;
      }

      // Verify with TON blockchain
      const isVerified = await this.tonService.verifyPayment(payment);
      
      if (isVerified) {
        await this.updatePaymentStatus(paymentId, 'completed');
        return true;
      }

      return false;

    } catch (error) {
      this.logger.error('Error verifying payment:', error);
      return false;
    }
  }

  public async cleanupExpiredPayments(): Promise<number> {
    try {
      const expiredPayments = await this.getExpiredPayments();
      let cleanedCount = 0;

      for (const payment of expiredPayments) {
        if (payment.status === 'pending') {
          await this.updatePaymentStatus(payment.id, 'expired');
          cleanedCount++;
        }
      }

      this.logger.info(`Cleaned up ${cleanedCount} expired payments`);
      return cleanedCount;

    } catch (error) {
      this.logger.error('Error cleaning up expired payments:', error);
      return 0;
    }
  }

  public getPaymentStatistics(merchantId: number): {
    totalPayments: number;
    completedPayments: number;
    pendingPayments: number;
    totalAmount: number;
    averageAmount: number;
  } {
    const merchantPayments = Array.from(this.payments.values())
      .filter(payment => payment.merchantId === merchantId);

    const totalPayments = merchantPayments.length;
    const completedPayments = merchantPayments.filter(p => p.status === 'completed').length;
    const pendingPayments = merchantPayments.filter(p => p.status === 'pending').length;
    const totalAmount = merchantPayments
      .filter(p => p.status === 'completed')
      .reduce((sum, p) => sum + p.amount, 0);
    const averageAmount = completedPayments > 0 ? totalAmount / completedPayments : 0;

    return {
      totalPayments,
      completedPayments,
      pendingPayments,
      totalAmount,
      averageAmount
    };
  }

  private validatePaymentRequest(request: PaymentRequest): void {
    if (!request.merchantId) {
      throw new Error('Merchant ID is required');
    }

    if (!request.amount || request.amount <= 0) {
      throw new Error('Amount must be greater than 0');
    }

    if (request.amount < appConfig.minPaymentAmount) {
      throw new Error(`Amount must be at least ${appConfig.minPaymentAmount}`);
    }

    if (request.amount > appConfig.maxPaymentAmount) {
      throw new Error(`Amount cannot exceed ${appConfig.maxPaymentAmount}`);
    }

    if (!request.currency || request.currency.length !== 3) {
      throw new Error('Currency must be a 3-letter code');
    }

    if (!['TON', 'jUSDT'].includes(request.tokenType)) {
      throw new Error('Invalid token type');
    }
  }

  private calculateTokenAmount(amount: number, exchangeRate: number): number {
    const tokenAmount = amount * exchangeRate;
    
    // Round to 4 decimal places for TON, 2 for jUSDT
    const decimals = 4;
    return Math.round(tokenAmount * Math.pow(10, decimals)) / Math.pow(10, decimals);
  }

  public async refreshPayment(paymentId: string): Promise<Payment | null> {
    try {
      const payment = this.payments.get(paymentId);
      
      if (!payment) {
        return null;
      }

      // Get fresh exchange rate
      const exchangeRate = await this.exchangeRateService.getExchangeRate(
        payment.currency,
        payment.tokenType
      );

      // Recalculate token amount
      payment.tokenAmount = this.calculateTokenAmount(payment.amount, exchangeRate);
      payment.expiresAt = new Date(Date.now() + appConfig.paymentTimeout);

      this.payments.set(paymentId, payment);

      this.logger.info('Payment refreshed', {
        paymentId,
        newTokenAmount: payment.tokenAmount,
        newExpiresAt: payment.expiresAt
      });

      return payment;

    } catch (error) {
      this.logger.error('Error refreshing payment:', error);
      throw error;
    }
  }
} 